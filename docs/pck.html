---
layout: chapter
title: "Actionable Approximations of the Truth"
---
<h1 id="s:pck">7) Actionable Approximations of the Truth</h1>
<blockquote>
<p><strong>After reading this chapter, you will be able to<span>…</span></strong></p>
<ul>
<li>Explain what pedagogical content knowledge (PCK) is and why it’s important.</li>
<li>Explain what the “superbug” in novice programming is, and at least two other misconceptions novices often have.</li>
<li>Describe what blocks-based programming tools are and why they are easier for novices to learn than text-based systems.</li>
<li>Describe the effects that error messages, variable naming, and visualization have on novices’ performance.</li>
<li>Summarize the effectiveness of various intervention strategies on novice learning.</li>
</ul>
</blockquote>
<p>Every instructor needs three things:</p>
<ul>
<li><a class="glossref" href="./gloss.html#g:content-knowledge"><strong>content knowledge</strong></a>, such as how to program;</li>
<li><a class="glossref" href="./gloss.html#g:general-pedagogical-knowledge"><strong>general pedagogical knowledge</strong></a>, such as an understanding of the psychology of learning; and</li>
<li><a class="glossref" href="./gloss.html#g:pedagogical-content-knowledge"><strong>pedagogical content knowledge</strong></a> (PCK), which is the domain-specific knowledge of how to teach a particular concept to a particular audience.</li>
</ul>
<p>In computing, PCK includes things like what examples to use when teaching how parameters are passed to a function, or what misconceptions about nesting HTML tags are most common. This chapter summarizes some results from research into teaching and learning programming that will add to your store of PCK.</p>
<p>Computing education research is still a young discipline: while the American Society for Engineering Education was founded in 1893, and the National Council of Teachers of Mathematics in 1920, the Computer Science Teachers Association didn’t exist until 2005. The simple truth is that we don’t know as much about how people learn to program as we do about how they learn to read, play a sport, or do basic arithmetic. However, conferences like <a href="http://sigcse.org/">SIGCSE</a>, <a href="http://iticse.acm.org/">ITiCSE</a> and <a href="https://icer.hosting.acm.org">ICER</a> are delivering an ever-increasing stream of rigorous, insightful studies with practical application. (For those interested in methods these studies rely on, [<a href="./bib.html#Ihan2016">Ihan2016</a>] summarizes the ones used most often.)</p>
<p>As with all research, though, some caution is required to interpret these results. Most studies look at school children and university undergraduates, both because those are the populations that researchers have easiest access to [<a href="./bib.html#Henr2010">Henr2010</a>] and because those are the ages at which people most often learn to program; less is known about adults learning to program in free-range settings.</p>
<p>Theories may change as more and better data becomes available, so if this was an academic treatise, it would preface most claims with statements like, “Research may seem to indicate that<span>…</span>” However, since actual teachers in actual classrooms have to make decisions regardless of whether research has clear answers yet or not, this chapter presents actionable approximations of the truth rather than nuanced perhapses.</p>
<blockquote>
<p><strong>Jargon</strong></p>
<p>Like any specialty, computing education research has its jargon. The term <a class="glossref" href="./gloss.html#g:cs1"><strong>CS1</strong></a> refers to an introductory semester-long programming course in which learners meet variables, loops, and functions for the first time, while <a class="glossref" href="./gloss.html#g:cs2"><strong>CS2</strong></a> refers to a second course that covers basic data structures like stacks and queues. The term <a class="glossref" href="./gloss.html#g:cs0"><strong>CS0</strong></a> is also now being used to refer to an introductory course for people without any prior experience who aren’t intending to continue with computing (at least not right away).</p>
<p>A CS1 course is often useful for undergraduates in other disciplines; a CS2 course designed for computer science learners is usually less relevant for artists, ecologists, and other <a class="glossref" href="./gloss.html#g:end-user-programmer"><strong>end-user programmers</strong></a>, but is sometimes the only next step available at their institution. Full definitions for these terms and others can be found in the <a href="https://www.acm.org/education/curricula-recommendations">ACM Curriculum Guidelines</a>.</p>
</blockquote>
<h2 id="s:pck-programming">7.1) How Do Novices Program?</h2>
<p>[<a href="./bib.html#Solo1984">Solo1984</a>,<a href="./bib.html#Solo1986">Solo1986</a>] pioneered the exploration of novice and expert programming strategies. The key finding is that experts know both “what” and “how”, i.e., they understand what to put into programs <em>and</em> they have a set of patterns or plans to guide their construction. Novices lack both, but most teachers focus solely on the former, even though bugs are often caused by not having a strategy for solving the problem rather than to lack of knowledge about the language.</p>
<p>The most important recommendation in this chapter is therefore to <em>show learners how to program</em>. This is consistent with the work on cognitive load theory presented in <a href="./load.html">Chapter 4</a>, and [<a href="./bib.html#Mull2007b">Mull2007b</a>] is just one of many studies proving its benefits; live coding (<a href="./performance.html#s:performance-live">Section 8.4</a>) is effective in part because it puts “how” front and center.</p>
<p>When demonstrating the act of programming, teachers should emphasize the importance of small steps with frequent feedback [<a href="./bib.html#Blik2014">Blik2014</a>]. They should also emphasize the importance of picking a plan and sticking to it rather than making more-or-less random changes to the program and hoping that they’ll work—as [<a href="./bib.html#Spoh1985">Spoh1985</a>] found, merging plans and/or goals can yield bugs because of goals being dropped or fragmented.</p>
<p>Another aspect of “how” that teachers should present and discuss is the order in which code is written. [<a href="./bib.html#Ihan2011">Ihan2011</a>] describes a tool for solving Parsons Problems. They found that experienced programmers often drag the method signature to the beginning, then add the majority of the control flow (i.e., loops and conditionals), and only then add details like variable initialization and handling of corner cases. This out-of-order authoring is foreign to novices, who read and write code in the order it’s presented on the page; again, one of the benefits of live coding (<a href="./performance.html#s:performance-live">Section 8.4</a>) is that it gives them a chance to see the sequence that more advanced programmers actually use.</p>
<h3 id="roles-of-variables" class="unnumbered">Roles of Variables</h3>
<p>One body of work that I have found very useful in teaching programming plans to novices is the collection of single-variable design patterns in [<a href="./bib.html#Kuit2004">Kuit2004</a>,<a href="./bib.html#Byck2005">Byck2005</a>,<a href="./bib.html#Saja2006">Saja2006</a>]. Labelling the parts of novices’ programs gives them a vocabulary to think with and a set of programming plans for constructing code of their own. The patterns are listed on the <a href="http://saja.kapsi.fi/var_roles/">Roles of Variables website</a>, which also includes examples of each:</p>
<dl>
<dt>Fixed value:</dt>
<dd><p>A data item that does not get a new proper value after its initialization.</p>
</dd>
<dt>Stepper:</dt>
<dd><p>A data item stepping through a systematic, predictable succession of values.</p>
</dd>
<dt>Walker:</dt>
<dd><p>A data item traversing in a data structure.</p>
</dd>
<dt>Most-recent holder:</dt>
<dd><p>A data item holding the latest value encountered in going through a succession of unpredictable values, or simply the latest value obtained as input.</p>
</dd>
<dt>Most-wanted holder:</dt>
<dd><p>A data item holding the best or otherwise most appropriate value encountered so far.</p>
</dd>
<dt>Gatherer:</dt>
<dd><p>A data item accumulating the effect of individual values.</p>
</dd>
<dt>Follower:</dt>
<dd><p>A data item that gets its new value always from the old value of some other data item.</p>
</dd>
<dt>One-way flag:</dt>
<dd><p>A two-valued data item that cannot get its initial value once the value has been changed.</p>
</dd>
<dt>Temporary:</dt>
<dd><p>A data item holding some value for a very short time only.</p>
</dd>
<dt>Organizer:</dt>
<dd><p>A data structure storing elements that can be rearranged.</p>
</dd>
<dt>Container:</dt>
<dd><p>A data structure storing elements that can be added and removed.</p>
</dd>
</dl>
<h2 id="s:pck-debug">7.2) How Do Novices Debug and Test?</h2>
<p>A decade ago, [<a href="./bib.html#McCa2008">McCa2008</a>] wrote, “It is surprising how little page space is devoted to bugs and debugging in most introductory programming textbooks.” Little has changed since: there are hundreds of books on compilers and operating systems, but only a handful about debugging, and I have never seen an undergraduate course on the subject. One reason is that debugging is a “how” rather than a “what”; again, one of the benefits of live coding is that it gives teachers a chance to demonstrate the process in a way that textbooks cannot (<a href="./performance.html#s:performance-live">Section 8.4</a>).</p>
<p>[<a href="./bib.html#List2004">List2004</a>,<a href="./bib.html#List2009">List2009</a>] found that many novices struggled to predict the output of short pieces of code and to select the correct completion of the code from a set of possibilities when told what it was supposed to do. More recently, [<a href="./bib.html#Harr2018">Harr2018</a>] found that the gap between being able to trace code and being able to write it has largely closed by CS2, but that novices who still have a gap (in either direction) are likely to do poorly in the course.</p>
<p>Our second recommendation is therefore to <em>teach novices how to debug</em>. [<a href="./bib.html#Fitz2008">Fitz2008</a>,<a href="./bib.html#Murp2008">Murp2008</a>] found that good debuggers were good programmers, but not all good programmers were good at debugging. Those who were used a symbolic debugger to step through their programs, traced execution by hand, wrote tests, and re-read the spec frequently, which are all teachable habits. However, tracing execution step by step was sometimes used ineffectively: for example, a novice might put the same <code>print</code> statement in both parts of an <code>if</code>-<code>else</code>. Novices would also comment out lines that were actually correct as they tried to isolate a problem; teachers can make both of these mistakes deliberately, point them out, and correct them to help novices get past them.</p>
<p>Teaching novices how to debug can also help make classes easier to manage. [<a href="./bib.html#Alqa2017">Alqa2017</a>] found that learners with more experience solved debugging problems significantly faster, but times varied widely: 4–10 minutes was a typical range for individual exercises, which means that some learners need 2–3 times longer than others to get through the same exercises. Teaching the slower learners what the faster ones are doing will help make the group’s overall progress more uniform.</p>
<p>Debugging depends on being able to read code, which multiple studies have shown is the single most effective way to find bugs [<a href="./bib.html#Basi1987">Basi1987</a>,<a href="./bib.html#Keme2009">Keme2009</a>,<a href="./bib.html#Bacc2013">Bacc2013</a>]. The code quality rubric developed in [<a href="./bib.html#Steg2014">Steg2014</a>,<a href="./bib.html#Steg2016a">Steg2016a</a>], which is online at [<a href="./bib.html#Steg2016b">Steg2016b</a>], is a good checklist of things to look for, though it is best presented in chunks rather than all at once.</p>
<p>Having learners read code and summarize its behavior is a good exercise (<a href="./individual.html#s:individual-strategies">Section 5.1</a>), but often takes too long to be practical in class. Having them predict a program’s output just before it is run, on the other hand, helps reinforce learning (<a href="./classroom.html#s:classroom-practices">Section 9.11</a>) and also gives them a natural moment to ask “what if” questions. Instructors or learners can also trace changes to variables as they go along (<a href="./pck.html#f:pck-sketch">Figure 7.1</a>), which [<a href="./bib.html#Cunn2017">Cunn2017</a>] found was effective.</p>

<figure>
<img src="./fig/sketching-variables.svg" /><figcaption id="f:pck-sketch">Figure 7.1: Tracing the Values of Variables)</figcaption>
</figure>
<p>When it comes to testing, novices seem just as reluctant to do it as professional programmers. There’s no doubt it’s valuable—[<a href="./bib.html#Cart2017">Cart2017</a>] found that high-performing novices spent a lot of time testing, while low performers spent much more time working on code with errors—and many instructors require learners to write tests for assignments. The question is, how well do they do this?</p>
<p>One answer comes from [<a href="./bib.html#Bria2015">Bria2015</a>], which scored learners’ programs by how many teacher-provided test cases those programs passed, and conversely scores test cases written by learners according to how many deliberately-seeded bugs they caught. They found that novices’ tests often have low coverage (i.e., they don’t test most of the code) and that they often test many things at once, which makes it hard to pinpoint the causes of errors.</p>
<p>Another answer comes from [<a href="./bib.html#Edwa2014b">Edwa2014b</a>], which looked at all of the bugs in all novices’ code submissions combined and identified those detected by the novices’ test suite. They found that novices’ tests only detected an average of 13.6% of the faults present in the entire program population. What’s more, 90% of the novices’ tests were very similar, which indicates that novices mostly write tests to confirm that code is doing what it’s supposed to rather than to find cases where it isn’t.</p>
<p>One approach to teaching better testing practices is to define a programming problem by providing a set of tests to be passed rather than through a written description (<a href="./exercises.html#s:exercises-classics">Section 12.1</a>). Before doing this, though, take a moment to look at how many tests you’ve written for your own code recently, and then decide whether you’re teaching what you believe people should do, or what they (and you) actually do.</p>
<h2 id="s:pck-misunderstand">7.3) What Misconceptions Do Novices Have?</h2>
<p><a href="./models.html">Chapter 2</a> explained why clearing up novices misconceptions is just as important as teaching them strategies for solving problems. The biggest misconception novices have—sometimes called the “superbug” in coding—is the belief that they can communicate with a computer in the same way that they would with a human being, i.e., that the computer understands intention the way that a human being would [<a href="./bib.html#Pea1986">Pea1986</a>]. Our third recommendation is therefore to <em>teach novices that computers don’t understand programs</em>, i.e., that calling a variable “cost” doesn’t guarantee that its value is actually a cost.</p>
<p>[<a href="./bib.html#Sorv2018">Sorv2018</a>] presents over 40 other misconceptions that instructors can also try to clear up, many of which are also discussed in [<a href="./bib.html#Qian2017">Qian2017</a>]’s survey. One is the belief that variables in programs work the same way they do in spreadsheets, i.e., that after executing:</p>
<pre><code>grade = 65
total = grade + 10
grade = 80
print(total)</code></pre>
<p>the value of <code>total</code> will be 90 rather than 75 [<a href="./bib.html#Kohn2017">Kohn2017</a>]. (This is an example of the way in which novices construct a plausible-but-wrong mental model by making analogies.) Other misconceptions include:</p>
<ul>
<li>A variable holds the history of the values it has been assigned, i.e., it remembers what its value used to be.</li>
<li>Two objects with the same value for a <code>name</code> or <code>id</code> attribute are guaranteed to be the same object.</li>
<li>Functions are executed as they are defined, or are executed in the order in which they are defined.</li>
<li>A <code>while</code> loop’s condition is constantly evaluated, and the loop stops as soon as it becomes false. Conversely, the conditions in <code>if</code> statements are also constantly evaluated, and their statements are executed as soon as the condition becomes true, no matter where the flow of control is at the time.</li>
<li>Assignment moves values, i.e., after <code>a = b</code>, the variable <code>b</code> is empty.</li>
</ul>
<p>Instead of looking directly at misconceptions, [<a href="./bib.html#Muhl2016">Muhl2016</a>] analyzed 350 concept maps and compared those who had done a CS course and those who had not. Unsurprisingly, they found that the maps drawn by those with previous experience looked more like the maps experts would draw, but the details highlighted what exactly learners were taking away from their lessons: “program” was a central concept in both sets of concept maps, but the next most central for those with prior exposure were “class” (in the object-oriented sense) and “data structure”, while for those without, they were “processor” and “data”.</p>
<h2 id="s:pck-mistakes">7.4) What Mistakes Do Novices Make?</h2>
<p>The mistakes novices make can tell us what to prioritize in our teaching, but it turns out that most teachers don’t know how common different kinds of mistakes actually are. The largest study of this is [<a href="./bib.html#Brow2017">Brow2017</a>]’s study of novice Java programs, which found that Mismatched quotes and parentheses are the most common type of error, but also the easiest to fix, while some mistakes (like putting the condition of an <code>if</code> in <code>{}</code> instead of <code>()</code>) are most often made only once. Unsurprisingly, mistakes that produce compiler errors are fixed much faster than ones that don’t.</p>
<p>Some mistakes, however, are made many times, like invoking methods with the wrong arguments (e.g., passing a string instead of an integer). One caution when reading this research is how important it is to distinguish mistakes from work in progress: for example, an empty <code>if</code> statement or a method that’s defined but not yet used may be a sign of incomplete code rather than an error.</p>
<p>[<a href="./bib.html#Brow2017">Brow2017</a>] also compared the mistakes novices actually make with what their teachers thought they made. They found that, “<span>…</span>educators formed only a weak consensus about which mistakes are most frequent, that their rankings bore only a moderate correspondence to the students in the<span>…</span>data, and that educators’ experience had no effect on this level of agreement.” For example, mistaking <code>=</code> (assignment) and <code>==</code> (equality) in loop condition tests wasn’t nearly as common as most teachers believed.</p>

<blockquote>
<p><strong>Not Just for Code</strong></p>
<p>[<a href="./bib.html#Park2015">Park2015</a>] collected data from an online HTML editor during an introductory web development course. Nearly all learners made syntax errors that remained unresolved weeks into the course. 20% of these errors related to the relatively complex rules that dictate <em>when</em> it is valid for HTML elements to be nested in one another, but 35% related to the simpler tag syntax determining <em>how</em> HTML elements are nested. (The tendency of many instructors to say, “But the rules are simple,” is a good example of expert blind spot discussed in <a href="./memory.html">Chapter 3</a><span>…</span>)</p>
</blockquote>
<h2 id="s:pck-now">7.5) What Are We Teaching Them Now?</h2>
<p>Very little is known about what coding bootcamps and other free-range initiatives teach, in part because many are reluctant to share their curriculum. We do know more about what is taught in schools: [<a href="./bib.html#Luxt2017">Luxt2017</a>] surveyed the topics included in introductory programming courses, categorized their findings under a dozen headings, and ranked them by frequency:</p>

<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Topic</td>
<td style="text-align: right;">Number of Courses</td>
<td style="text-align: right;">(%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Programming Process</td>
<td style="text-align: right;">90</td>
<td style="text-align: right;">(87%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Abstract Programming Thinking</td>
<td style="text-align: right;">65</td>
<td style="text-align: right;">(63%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Structures</td>
<td style="text-align: right;">41</td>
<td style="text-align: right;">(40%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Object-Oriented Concepts</td>
<td style="text-align: right;">37</td>
<td style="text-align: right;">(36%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Control Structures</td>
<td style="text-align: right;">34</td>
<td style="text-align: right;">(33%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Operations &amp; Functions</td>
<td style="text-align: right;">27</td>
<td style="text-align: right;">(26%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Types</td>
<td style="text-align: right;">24</td>
<td style="text-align: right;">(23%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Input/Output</td>
<td style="text-align: right;">18</td>
<td style="text-align: right;">(17%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Libraries</td>
<td style="text-align: right;">15</td>
<td style="text-align: right;">(15%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Variables &amp; Assignment</td>
<td style="text-align: right;">14</td>
<td style="text-align: right;">(14%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Recursion</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">(10%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Pointers &amp; Memory Management</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">(5%)</td>
</tr>
</tbody>
</table>
<p>This paper also showed how concepts are connected. For example, it’s impossible to explain how operator precedence works without first explaining a few operators, and difficult to explain those in a meaningful way without first introducing variables (because otherwise you’re comparing constants in expressions like <code>5&lt;3</code>, which is confusing).</p>
<p>Similarly, [<a href="./bib.html#Rich2017">Rich2017</a>] reviewed a hundred articles to find learning trajectories for computing classes in elementary and middle schools, and presented results for sequencing, repetition, and conditionals. These are essentially collective concept maps, as they combine and rationalize the implicit and explicit thinking of many different educators. <a href="./pck.html#f:pck-trajectory">Figure 7.2</a> shows the learning trajectories for conditionals.</p>

<figure>
<img src="./fig/conditionals.svg" /><figcaption id="f:pck-trajectory">Figure 7.2: Learning Trajectory for Conditions (from [<a href="./bib.html#Rich2017">Rich2017</a>])</figcaption>
</figure>
<p>But there can be a world of difference between what instructors teach and what learners learn, and study after study has shown that teaching evaluations don’t correlate with actual learning outcomes [<a href="./bib.html#Star2014">Star2014</a>,<a href="./bib.html#Uttl2017">Uttl2017</a>]. To find out how much novices are actually learning, we therefore have to use other measures or do direct studies. Taking the former approach, roughly two-thirds of post-secondary students pass their first computing course, with some variations depending on class size and so on, but with no significant differences over time or based on language [<a href="./bib.html#Benn2007a">Benn2007a</a>,<a href="./bib.html#Wats2014">Wats2014</a>].</p>
<p>How does prior experience affect these results? To find out, [<a href="./bib.html#Wilc2018">Wilc2018</a>] compared the performance and confidence of novices with and without prior programming experience in CS1 and CS2. They found that novices with prior experience outscored novices without by 10% in CS1, but those differences disappeared by the end of CS2. They also found that women with prior exposure outperformed their male peers in all areas, but were consistently less confident in their abilities; we will return to this issue in <a href="./motivation.html#s:motivation-inclusivity">Section 10.4</a>.</p>
<p>As for direct studies of how much novices learn, [<a href="./bib.html#McCr2001">McCr2001</a>] presented a multi-site international study, which was later replicated by [<a href="./bib.html#Utti2013">Utti2013</a>]. According to the first study, “<span>…</span>the disappointing results suggest that many students do not know how to program at the conclusion of their introductory courses.” More specifically, “For a combined sample of 216 students from four universities, the average score was 22.89 out of 110 points on the general evaluation criteria developed for this study.” This result may say as much about teachers’ expectations as it does about student ability, but either way, our fourth recommendation is to <em>measure and track results</em> in ways that can be compared over time, so that you can tell if your lessons are becoming more or less effective.</p>
<h2 id="s:pck-language">7.6) Do Languages Matter?</h2>
<p>The short answer is “yes”: novices learn to program faster and also learn more using blocks-based tools like Scratch (<a href="./pck.html#f:pck-scratch">Figure 7.3</a>) that make syntax errors impossible [<a href="./bib.html#Wein2017b">Wein2017b</a>]. And block interfaces encourage exploration in a way that text does not; like all good tools, Scratch can be learned accidentally [<a href="./bib.html#Malo2010">Malo2010</a>].</p>
<p>Our fifth recommendation is therefore to <em>start children and teens with blocks-based interfaces</em> before moving to text-based systems. The age qualification is there because Scratch (deliberately) looks like it’s meant for younger users; while imitators like <a href="https://developers.google.com/blockly/">Blockly</a> look more grown-up, it can still be hard to convince adults to take them seriously.</p>

<figure>
<img src="./fig/scratch.jpg" alt="Figure 7.3: Scratch (from https://opensource.com/article/18/4/designing-game-scratch-open-jam)" /><figcaption id="f:pck-scratch">Figure 7.3: Scratch (from <a href="https://opensource.com/article/18/4/designing-game-scratch-open-jam" class="uri">https://opensource.com/article/18/4/designing-game-scratch-open-jam</a>)</figcaption>
</figure>
<p>Scratch has probably been studied more than any other programming tool, and we know a great deal about how it is used. As just one example, [<a href="./bib.html#Aiva2016">Aiva2016</a>] analyzed over 250,000 Scratch projects and found (among other things) that about 28% of projects have some blocks that are never called or triggered. The authors hypothesize that users may be using them as a scratchpad to keep bits of code they don’t (yet) want to throw away.</p>
<p>[<a href="./bib.html#Grov2017">Grov2017</a>,<a href="./bib.html#Mlad2017">Mlad2017</a>] studied novices learning about loops in Scratch, Logo, and Python, and found that misconceptions about loops are minimized when using a block-based language rather than a text-based language. What’s more, as tasks become more complex (such as using nested loops) the differences become larger.</p>
<p>[<a href="./bib.html#Wein2017a">Wein2017a</a>] studied people using a tool that allowed them to switch between blocks and text for programming. They found that learners tend to migrate from blocks to text over time, but when learners shifted from text to blocks, their next action was to add a new type of command. This may be because browsing available commands is easier with blocks, or because blocks make syntax errors with unfamiliar new commands impossible. The authors say, “While it is often claimed that blocks-based programming environments offer the advantage of reducing syntax errors, our findings suggest that blocks also offer information about what is possible in the space and provide a low-stakes means of exploring unfamiliar code.” New tools like <a href="https://www.greenfoot.org/frames/">Stride</a> are trying to smooth the transition between blocks and text even further; when combined with programming notebooks like <a href="http://jupyter.org/">Jupyter</a> and <a href="http://stenci.la/">Stencila</a>, they may eventually eliminate the distinction altogether.</p>
<blockquote>
<p><strong>Harder Than Necessary</strong></p>
<p>[<a href="./bib.html#Stef2013">Stef2013</a>] has shown that the creators of programming language make those languages harder to learn by not doing basic usability testing. For example, “<span>…</span>the three most common words for looping in computer science, <code>for</code>, <code>while</code>, and <code>foreach</code>, were rated as the three most unintuitive choices by non-programmers.” More fundamentally, their work shows that C-style syntax (as used in Java and Perl) is just as hard for novices to learn as a randomly-designed syntax, but that the syntax of languages such as Python and Ruby is significantly easier to learn, and the syntax of their own language, Quorum, is easier still, because they are testing each new feature before adding it to the language. ([<a href="./bib.html#Stef2017">Stef2017</a>] is a useful brief summary of what we actually know about designing programming languages and why we believe it’s true.)</p>
</blockquote>
<h3 id="object-oriented-and-functional-programming" class="unnumbered">Object-Oriented and Functional Programming</h3>
<p>Objects and classes are power tools for experienced programmers, and many educators advocate an “objects first” approach to teaching programming (though they sometimes disagree on exactly what that means [<a href="./bib.html#Benn2007b">Benn2007b</a>]). [<a href="./bib.html#Sorv2014">Sorv2014</a>] describes and motivates this approach, and [<a href="./bib.html#Koll2015">Koll2015</a>] describes three generations of tools designed to support novice programming in object-oriented environments.</p>
<p>Introducing objects early has a few special challenges. [<a href="./bib.html#Mill2016b">Mill2016b</a>] found that most novices using Python struggled to understand <code>self</code> (which refers to “this object”): they omitted it in method definitions, failed to use it when referencing object attributes, or both. Object reference errors were also more common than other errors; the authors speculate that this is partly due to the difference in syntax between <code>obj.method(param)</code> and <code>def method(self, param)</code>. [<a href="./bib.html#Rago2017">Rago2017</a>] found something similar in high school students, and that high school teachers often weren’t clear on the concept either.</p>
<p>Another approach is exemplified by the <a href="http://www.bootstrapworld.org/">Bootstrap project</a>, which is based on the <a class="glossref" href="./gloss.html#g:functional-programming"><strong>functional programming</strong></a> paradigm. This work draws on a rich tradition going back to languages like Scheme and Lisp, and to classic textbooks like [<a href="./bib.html#Fell2001">Fell2001</a>,<a href="./bib.html#Frie1995">Frie1995</a>,<a href="./bib.html#Abel1996">Abel1996</a>]. If functional programming continues to gain ground among professional programmers, this approach may grow more popular for teaching.</p>
<p>On balance, we recommend that instructors <em>use procedural languages</em> to start with, i.e., that defining classes and using higher-order functions not be taught until learners understand basic control structures and data types. How quickly these topics should be introduced depends on the audience: if learners want to build web applications in JavaScript, for example, they’re going to have to master callbacks much earlier than if they want to generate reports using C#.</p>
<h3 id="type-declarations" class="unnumbered">Type Declarations</h3>
<p>Programmers have argued for decades about whether variables’ data types should have to be declared or not. One recent empirical finding is [<a href="./bib.html#Gao2017">Gao2017</a>], which found that about 15% of bugs in JavaScript programs could be caught by requiring type declarations, which is either high or low depending on what answer you wanted in the first place.</p>
<p>However, programming and learning to program are different activities, and results from the former don’t necessarily apply to the latter. [<a href="./bib.html#Endr2014">Endr2014</a>] found that requiring novices to declare variable types does add some complexity to programs, but it pays off fairly quickly by acting as documentation for a method’s use—in particular, by forestalling questions about what’s available and how to use it.</p>
<p>We don’t know enough yet to recommend typed or untyped languages for novices. Now that Python allows optional typing, though, it may be feasible for researchers to explore whether it can or should be introduced gradually.</p>
<h3 id="does-variable-naming-style-matter" class="unnumbered">Does Variable Naming Style Matter?</h3>
<p>[<a href="./bib.html#Kern1999">Kern1999</a>] says, “Programmers are often encouraged to use long variable names regardless of context. This is a mistake: clarity is often achieved through brevity.” Lots of programmers believe this, but [<a href="./bib.html#Hofm2017">Hofm2017</a>] found that using full words in variable names led to an average of 19% faster comprehension compared to letters and abbreviations.</p>
<p>In contrast, [<a href="./bib.html#Beni2017">Beni2017</a>] found that using single-letter variable names didn’t affect novices’ ability to modify code. This may be because their programs are shorter than professionals’, or because some single-letter variable names have implicit types and meanings: most programmers assume <code>i</code>, <code>j</code>, and <code>n</code> are integers, and <code>s</code> is a string, while <code>x</code>, <code>y</code>, and <code>z</code> are either floating-point numbers or integers more or less equally.</p>
<p>How important is this? [<a href="./bib.html#Bink2012">Bink2012</a>] reported a series of studies that found that reading and understanding code is fundamentally different from reading prose: “<span>…</span>the more formal structure and syntax of source code allows programmers to assimilate and comprehend parts of the code quite rapidly independent of style. In particular<span>…</span>beacons and program plans play a large role in comprehension.” It also found that experienced developers are relatively unaffected by identifier style, so our recommendation is just to use consistent style in all examples.</p>
<p>Since most languages have style guides (e.g., <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> for Python) and tools to check that code follows these guidelines, our full recommendation is to <em>use tools to ensure that all code examples adhere to a consistent style</em>.</p>
<h2 id="s:pck-error">7.7) Does Better Feedback Help?</h2>
<p>Incomprehensible error messages are a major source of frustration for novices (and sometimes for experienced programmers as well). Several researchers have therefore explored whether better error messages would help alleviate this. For example, [<a href="./bib.html#Beck2016">Beck2016</a>] rewrote some of the Java compiler’s messages so that instead of:</p>
<pre><code>C:\stj\Hello.java:2: error: cannot find symbol
        public static void main(string[ ] args){
^
1 error
Process terminated ... there were problems.</code></pre>
<p>learners would see:</p>
<pre><code>Looks like a problem on line number 2.
If &quot;string&quot; refers to a datatype, capitalize the &#39;s&#39;!</code></pre>
<p>Sure enough, novices given these messages made fewer repeated errors and fewer errors overall.</p>
<p>[<a href="./bib.html#Bari2017">Bari2017</a>] went further and used eye tracking to show that despite the grumblings of compiler writers, people really do read error messages—in fact, they spend 13–25% of their time doing this. However, reading error messages turns out to be as difficult as reading source code, and how difficult it is to read the error messages strongly predicts task performance. Instructors should therefore <em>give learners practice in reading and interpreting error messages</em>. [<a href="./bib.html#Marc2011">Marc2011</a>] has a rubric for responses to error messages that can be useful in grading such exercises.</p>
<h3 id="does-visualization-help" class="unnumbered">Does Visualization Help?</h3>
<p>The idea of visualizing programs is perennially popular, and tools like [<a href="./bib.html#Guo2013">Guo2013</a>] (a web-based tool for visualizing the execution of Python programs) and <a href="http://latentflip.com/loupe/">Loupe</a> (which shows how JavaScript’s event loop works) are both useful teaching aids. However, people learn more from constructing visualizations than they do from viewing visualizations constructed by others [<a href="./bib.html#Stas1998">Stas1998</a>,<a href="./bib.html#Ceti2016">Ceti2016</a>], so does visualization actually help learning?</p>
<p>To answer this, [<a href="./bib.html#Cunn2017">Cunn2017</a>] replicated an earlier study of the kinds of sketching students do when tracing code execution. They found that not sketching at all correlates with lower success, while tracing changes to variables’ values by writing new values near their names as they change was the most effective strategy (<a href="./pck.html#f:pck-sketch">Figure 7.1</a>).</p>
<p>One possible confounding effect they checked was time: since sketchers take significantly more time to solve problems, do they do better just because they think for longer? The answer is no: there was no correlation between the time taken and the score achieved. Our recommendation is therefore to <em>teach students to trace variables’ values when debugging</em>.</p>
<blockquote>
<p><strong>Flowcharts</strong></p>
<p>One often-overlooked finding about visualization is that students understand flowcharts better than pseudocode <em>if both are equally well structured</em> [<a href="./bib.html#Scan1989">Scan1989</a>]. Earlier work showing that pseudocode outperformed flowcharts used structured pseudocode and tangled flowcharts; when the playing field was levelled, novices did better with the graphical representation.</p>
</blockquote>
<h2 id="s:pck-help">7.8) What Else Can We Do to Help?</h2>
<p>[<a href="./bib.html#Viha2014">Viha2014</a>] examined the average improvement in pass rates of various kinds of intervention in programming classes. As they themselves point out, there are many reasons to take their findings with a grain of salt: the pre-change teaching practices are rarely stated clearly, the quality of change is not judged, and only 8.3% of studies reported negative findings, so either there is positive reporting bias or the way we’re teaching right now is almost the worst way possible and anything would be an improvement. And like many other studies discussed in this chapter, they were only looking at university classes, so their findings may not generalize to other groups.</p>
<p>With all those caveats in mind, they found ten things instructors can do to improve outcomes (<a href="./pck.html#f:pck-interventions">Figure 7.4</a>):</p>
<dl>
<dt>Collaboration:</dt>
<dd><p>Activities that encourage student collaboration either in classrooms or labs.</p>
</dd>
<dt>Content Change:</dt>
<dd><p>Parts of the teaching material were changed or updated.</p>
</dd>
<dt>Contextualization:</dt>
<dd><p>Course content and activities were aligned towards a specific context such as games or media.</p>
</dd>
<dt>CS0:</dt>
<dd><p>Creation of a preliminary course to be taken before the introductory programming course; could be organized only for some (e.g., at-risk) students.</p>
</dd>
<dt>Game Theme:</dt>
<dd><p>A game-themed component was introduced to the course.</p>
</dd>
<dt>Grading Scheme:</dt>
<dd><p>A change in the grading scheme; the most common change was to increase the amount of points rewarded from programming activities, while reducing the weight of the course exam.</p>
</dd>
<dt>Group Work:</dt>
<dd><p>Activities with increased group work commitment such as team-based learning and cooperative learning.</p>
</dd>
<dt>Media Computation:</dt>
<dd><p>Activities explicitly declaring the use of media computation (<a href="./motivation.html">Chapter 10</a>).</p>
</dd>
<dt>Peer Support:</dt>
<dd><p>Support by peers in form of pairs, groups, hired peer mentors or tutors.</p>
</dd>
<dt>Other Support:</dt>
<dd><p>An umbrella term for all support activities, e.g. increased teacher hours, additional support channels, etc.</p>
</dd>
</dl>

<figure>
<img src="./fig/interventions.png" alt="Figure 7.4: Effectiveness of Interventions" /><figcaption id="f:pck-interventions">Figure 7.4: Effectiveness of Interventions</figcaption>
</figure>
<p>This list highlights the importance of cooperative learning. [<a href="./bib.html#Beck2013">Beck2013</a>] looked at this specifically over three academic years in courses taught by two different instructors, and found significant benefits overall and for many subgroups: they not only had higher grades, they left fewer questions blank on the final exam, which indicates greater self-efficacy and willingness to try to debug things.</p>
<p>As noted earlier, writing code isn’t the only way to teach people how to program. [<a href="./bib.html#Shel2017">Shel2017</a>] reports that having novices work on computational creativity exercises improves grades at several levels. A typical exercise is to identify an everyday object (such as nail clipper, a paper clip, Scotch tape) and describe the object in terms of its inputs, outputs and functions. This kind of teaching is sometimes called “unplugged”; the <a href="https://csunplugged.org/en/">CS Unplugged</a> site has a collection of lessons and exercises for doing this.</p>
<h2 id="s:pck-exercises">7.9) Exercises</h2>
<h3 id="checking-for-common-errors-individual20-minutes" class="unnumbered">Checking for Common Errors (<span>individual</span>/<span>20</span> minutes)</h3>
<p>This list of common errors is taken from [<a href="./bib.html#Sirk2012">Sirk2012</a>]. Pick three, and write an exercise for each to check that learners <em>aren’t</em> making that mistake.</p>
<dl>
<dt>Inverted assignment:</dt>
<dd><p>The student assigns the value of the left-hand variable to the right-hand side variable, rather than the other way around.</p>
</dd>
<dt>Wrong branch:</dt>
<dd><p>Even though the conditional evaluates to <code>False</code>, the student jumps to the <code>then</code> clause.</p>
</dd>
<dt>Wrong <code>False</code>:</dt>
<dd><p>As soon as the conditional evaluates to <code>False</code> , the student returns <code>False</code> from the function.</p>
</dd>
<dt>Executing function instead of defining it:</dt>
<dd><p>The student believes that a function is executed as it is defined.</p>
</dd>
<dt>Unevaluated parameters:</dt>
<dd><p>The student believes the function starts running before the parameters have been evaluated.</p>
</dd>
<dt>Parameter evaluated in the wrong frame:</dt>
<dd><p>The student creates parameter variables in the caller’s frame, not in the callee’s.</p>
</dd>
<dt>Failing to store return value:</dt>
<dd><p>The student does not assign the return value in the caller.</p>
</dd>
<dt>Assignment copies object:</dt>
<dd><p>The student creates a new object rather than copying a reference.</p>
</dd>
<dt>Method call without subject:</dt>
<dd><p>The student tries to call a method from a class without first creating an instance of the class.</p>
</dd>
</dl>
<h3 id="mangled-code-pairs15-minutes" class="unnumbered">Mangled Code (<span>pairs</span>/<span>15</span> minutes)</h3>
<p>[<a href="./bib.html#Chen2017">Chen2017</a>] describes exercises in which students reconstruct code that has been mangled by removing comments, deleting or replacing lines of code, moving lines, inserting extra unneeded lines, and so on. Student performance on these correlates strongly with performance on assessments in which students write code (i.e., whatever traditional assignments are measuring, these are measuring as well), but these questions require less (in-person) work to mark. Take the solution to a programming exercise you’ve created in the past, mangle it in two different ways, and swap with a partner.</p>
<h3 id="the-rainfall-problem-pairs10-minutes" class="unnumbered">The Rainfall Problem (<span>pairs</span>/<span>10</span> minutes)</h3>
<p>[<a href="./bib.html#Solo1986">Solo1986</a>] introduced the Rainfall Problem: write a program that repeatedly reads in positive integers until it reads the integer 99999. After seeing 99999, the program should print out the average of the numbers seen. This problem has been used in many subsequent studies of programming [<a href="./bib.html#Fisl2014">Fisl2014</a>,<a href="./bib.html#Simo2013">Simo2013</a>,<a href="./bib.html#Sepp2015">Sepp2015</a>].</p>
<p>Solve the Rainfall Problem in the programming language of your choice. Compare your solutions with those of your partner.</p>
<h3 id="roles-of-variables-pairs15-minutes" class="unnumbered">Roles of Variables (<span>pairs</span>/<span>15</span> minutes)</h3>
<p>Take a short program you have written (5–15 lines) and classify each of its variables using the categories defined in <a href="./pck.html#s:pck-programming">Section 7.1</a>. Compare your classifications with those of a partner: where did you agree? When you disagreed, did you understand each other’s view?</p>
<h3 id="choose-your-own-adventures-individual10-minutes" class="unnumbered">Choose Your Own Adventures (<span>individual</span>/<span>10</span> minutes)</h3>
<p>Which of the three approaches described in [<a href="./bib.html#Sorv2014">Sorv2014</a>] (<a href="./pck.html#s:pck-now">Section 7.5</a>) do you use when teaching? Or is your approach best described in some other way?</p>
<h3 id="what-are-you-teaching-individual10-minutes" class="unnumbered">What Are You Teaching? (<span>individual</span>/<span>10</span> minutes)</h3>
<p>Compare the topics you teach to the list developed in [<a href="./bib.html#Luxt2017">Luxt2017</a>] (<a href="./pck.html#s:pck-now">Section 7.5</a>). Which topics do you cover? What extra topics do you cover that aren’t in their list?</p>
<h3 id="beneficial-activities-individual10-minutes" class="unnumbered">Beneficial Activities (<span>individual</span>/<span>10</span> minutes)</h3>
<p>Look at the list of interventions developed by [<a href="./bib.html#Viha2014">Viha2014</a>] (<a href="./pck.html#s:pck-help">Section 7.8</a>). Which of these things do you already do in your classes? Which ones could you easily add? Which ones are irrelevant?</p>
<h3 id="visualizations-individual10-minutes" class="unnumbered">Visualizations (<span>individual</span>/<span>10</span> minutes)</h3>
<p>What visualization do you most like to use when teaching? Is it a static image or an animation? Do you show it to your learners, do they discover it on their own, or something in between?</p>
<h3 id="misconceptions-and-challenges-small-groups15-minutes" class="unnumbered">Misconceptions and Challenges (<span>small groups</span>/<span>15</span> minutes)</h3>
<p>The <a href="http://www.pd4cs.org/">Professional Development for CS Principles Teaching</a> site includes <a href="http://www.pd4cs.org/mc-index/">a detailed list of student misconceptions and exercises</a>. Working in small groups, choose one section (such as data structures or functions) and go through their list. Which of these misconceptions do you remember having when you were a learner? Which do you still have? Which have you seen in your learners?</p>
